
# 문제 제목

## 📋 문제 정보
- **플랫폼**: Baekjoon
- **문제 번호**: 2098
- **난이도**: Gold 1

---

## 🎯 문제 접근 방식

- **문제 분석 :**
외판원 순회

집의 개수 n 이 주어지고
각 도시를 갔다가 처음 시작 도시로 돌아왔을 때의 최소 비용을 구하는 문제.
도시의 시작점이 주어지지 않는 것이 관건.

dp만으로 풀면 왜 안되는가? -> n!
n의 최대 값은 16이기 때문에 87억 정도가 넘어서 제한시간 초과
일반 dp만 쓰면 방문 순서를 구분 못하기 때문에 모든 방문에 대한 메모리 공간이 필요.

-> 여기에서 또 중복되는 부분이 무조건 있잖아?
-> 비트마스팅으로 표현
ex) 0110 (2,3 번 도시 방문) 과 0010 (2번 도시 방문)은 2번 도시는 중복이 되기 때문에 이 중복을 해결할 수 있지 않을까?
-> 비트 마스킹 사용시 O(n² × 2ⁿ)


- **사용할 알고리즘/자료구조 :**
DP + 비트 마스킹
dp 배열의 상태
행 -> 내가 방문한 도시의 상황 mask
열 -> 내가 현재 위치한 도시
그럼 최대 마스킹 경우의 수를 생각해야하기 때문에 dp 배열 초기화는 n개의 최대 마스킹 값으로

방문 상태 mask 를 확보하면서 최소 비용 저장.
모든 도시 방문 후에는 u 부분에 도착했을때 최소 비영은 dp[all][u]가 된다.

마지막으로 for 문을 돌려 시작점을 각자 달리 하여 각 행마다 all (모든 도시를 방문한 경우) 인 bit 상태의 최솟값을 구하면 된다.




## 📊 복잡도 분석

- **O(n² × 2ⁿ)**

이분 탐색

## ⚡ 메모리/실행시간

### 결과
- **메모리**: 21,760KB
- **실행시간**: 180ms

### 기타 및 참고사항