
# 문제 제목

## 📋 문제 정보
- **플랫폼**: 백준
- **문제 번호**: 2138
- **난이도**: 골드 4

---

## 🎯 문제 접근 방식

- **문제 분석 :**
전구와 스위치

- 전구는 현재 인덱스 기중 i-1. i. i+1로 껐다 킬수가 있다. (현재 상태의 반대가 되므로 XOR 연산을 생각)
- 이때 목표 상태를 이루기 위한 가장 최소 횟수를 구하라
 



- **사용할 알고리즘/자료구조 :**
그리디
- 처음에는 중복 순열을 이용해서 모든 스위치를 껏다 키는 로직을 생각 -> 시간 폭발, 메모리 폭발
- 순서가 없이 스위치를 껏다 키는 순서를 모두 다 다르다고 생각을 했는데 1 - 2 - 3 순서와 3 - 2 - 1 순서가 결국 같다. (재용님 감사합니다) 그러면 처음 index 부터 차례대로 끄는지 안끄는지 탐색을 하면 된다!

- 문제에서는 i-1, i , i+1 의 상태가 바뀌지만 i-1 은 한번 지나면 상태를 바꿀 수 없고 i+1 은 그 다음의 i-1 상태가 되므로 바꿀수 있기 때문에 i-1의 상태를 목표값에 맞춘다고 생각

- 그럼 처음 시작의 경우는 0번 인덱스에서 끈 경우와 킨 경우로 크게 나뉜다. -> 끈 경우와 킨 경우의 두 상태를 나누어 기댓값(target)에 맞는 스위치 켜기/끄기 로직을 진행

- 다른 풀이를 보고 정말 이해안됐는데 재용님 풀이보고 한방에 이해했습니다. 그리고 XOR 연산하면 코드 구조가 더 간결해져서 이 부분은 좀 좋았다라고 생각합니다






## 📊 복잡도 분석

- **O(N)**

## ⚡ 메모리/실행시간

### 결과
- **메모리**: 16024kb
- **실행시간**: 104ms

### 기타 및 참고사항